= Go Patterns and Practices
Abhinav Gupta
2022-09-19
:revealjs_fragmentInURL: true
:revealjs_hash: true
:revealjs_navigationMode: linear
:revealjs_pdfseparatefragments: false
:revealjs_theme: black
:revealjs_totalTime: 2700
:customcss: style.css
:icons: font
:source-highlighter: highlightjs

== Hi

[.text-left]
I'm Abhinav.

[.text-center]
I work on Go frameworks.

[.text-right]
Let's talk about writing Go.

[.notes]
--
Hey folks, I'm Abhinav.

I lead the Go Platform team.
We own things like Fx, Glue, CFF2, Zap, etc.

Today I'll talk to you about writing good Go.
--

== Agenda

TODO: Fill this out

[.notes]
--
The agenda for this talk is roughly this,

* First, we'll discuss some rules we're operating under
  for good, maintainable packages and libraries.
* We'll talk about patterns we can use in that context.
* Practices

Okay, let's get started.
--

== Rules

:rule-exported: Exported means forever
:rule-functions: Function types are fixed
:rule-interfaces: Interfaces are immutable

. {rule-exported}
. {rule-functions}
. {rule-interfaces}

[.notes]
--
First, let's establish some rules for writing code.
These rules motivate the designs we'll discuss later.

These rules apply only to libraries,
but we tend to write most our code to meet these constraints.
If it's not part of core application logic, treat it like a library.

The rules are:

* Exported means forever
* Function types are fixed
* Interfaces are immutable

Let me quickly elaborate a bit on each.
--

[.columns.is-vcentered]
=== {rule-exported}

[.column]
Cannot remove

[.column.medium]
functions +
variable +
type +
constants

[.column]
once exported

[.notes]
--
Exported means forever.

Anything you export,
be it function, variable, type, or constant,
you cannot delete it once exported.

This reason for this should be obvious.
It'll break anyone using them.
--

[.columns.is-vcentered]
=== {rule-functions}

[.column]
Cannot modify

[.column.medium]
function +
or +
method

[.column]
signatures

[.notes]
--
Function types are fixed.

You cannot make any changes to a function or method signature.
--

[.columns.is-vcentered.wrap%conceal]
=== Why are functions types fixed

[.column.is-two-thirds]
[source,diff]
----
 func DeleteUser(
   ctx context.Context,
   name string,
+  softDelete bool,
 ) (...)
----

[.column.is-one-third]
adding a parameter

[.column.is-two-thirds]
[source,diff]
----
 func DeleteUser(...) (
  deleted bool,
+ uuid uuid.UUID,
  err  error,
 )
----

[.column.is-one-third]
or a return value

[.column.is-two-thirds]
[source,go]
----
// ERROR
// - missing parameter: softDelete
// - cannot assign 3 values to 2 variables
deleted, err := DeleteUser(ctx, name)
if err != nil {
  // ...
}
----

[.column.is-one-third]
breaks existing callers

[.notes]
--
Again, this should be obvious but I'll explain anyway.
You can't modify a function signature
because every modification you make
will break existing callers.
--

[.columns]
=== Variadic arguments

[.column]
--
[source,diff]
----
 func ListPosts(
   ctx context.Context,
+  skipAuthors ...string
 ) ([]*Post, error)
----

This is fine, right?

[source,go]
----
posts, err := ListPosts(ctx)
if err != nil {
  // ...
}
----

[step=1]
Nope!
--

[.column.is-three-fifths,step=1]
--
[source,go]
----
func Process(
  ctx context.Context,
  listPosts func(...) ([]*Post, error)
) {
  posts, err := listPosts(ctx)
  // ...
}
----

Breaks function references

[source,go]
----
Process(ctx, ListPosts)
// ERROR:
// want func(Context) (...)
//  got func(Context, ...string) (...)
----
--

[.notes]
--
Aha, some of you might be thinking.
What if I add variadic arguments to a function?
Surely, that's a backwards compatible change?
Surely, that won't break anyone.

Wrong.
Go supports function references.
When you pass a function reference,
the type is usually inferred.
Changing that type is a breaking change.
--

[.columns.is-vcentered]
=== {rule-interfaces}

[.column]
Cannot

[.column.medium]
modify +
remove +
*add*

[.column]
methods

[.notes]
--
Finally, interfaces are immutable.

You cannot modify or remove methods.
The reasons are the same as the last two sections.

However, the third one can be surprising.
You also cannot add methods.
Why?
--

[.columns.wrap%conceal]
=== Why you cannot add methods to an interface

[.column.is-full]
Adding methods to an interface

[.column]
[source,diff]
----
 type Writer interface {
   WriteBytes([]byte) error
+  WriteString(string) error
 }
----

[.column]
[source,go]
----
func WriteTo(w Writer) error {
  // ...
}
----

[.column.is-full]
breaks existing implementations

[.column]
[source,go]
----
type myWriter struct{ /* ... */ }

func (w *myWriter) WriteBytes(
  b []byte,
) error {
  // ...
}
----

[.column]
[source,go]
----
// ERROR:
// does not implement WriteString
err := WriteTo(&myWriter{...})
if err != nil {
  // ...
}
----

[.notes]
--
Adding new methods to an interface breaks existing implementations.
--

== Rules

. {rule-exported}
. {rule-functions}
. {rule-interfaces}

[.notes]
--
So to summarize, here are the rules again.

* Don't take away something you've given
* Don't change function signatures
* Don't change *anything* about interfaces

Okay, so we have some rules.
How do we operate inside them?
What patterns can we use to make sure we don't break them?
--

== Patterns

// TODO: Better title?

[.notes]
--
Let's cover them in order.
--

== {rule-exported}

* Be deliberate
* You can always export it later

[.notes]
--
Since there's no going back when you export something,

* Be deliberate in your choice of what you export.
  Just because it *might* be useful does not mean it should be exported.
* You can always export it later -- when you need it.
--

== {rule-functions}

How to plan for expansion?

[.notes]
--
So function types are fixed.
You can't change them.
How can you plan for expansion?

There are three primary methods.
--

[.columns]
=== Parameter Objects

[.column]
--
[source,diff]
----
 type DeleteUserRequest struct {
   Name       string
+  SoftDelete bool
 }
----

[source,go]
----
func DeleteUser(
  ctx context.Context,
  req DeleteUserRequest,
) (...) {
  // ...
}
----
--

[.column.text-left]
--
`struct` *exclusively* for parameters except `Context`

[.medium]
New *optional* fields

[%step.small]
Need more than 3 parameters? +
Use a `struct`.
--

[.notes]
--
The first tool you can use here is parameter objects.

That's just another way of saying that you should
define a struct *specifically* for your function's parameters.
This is important.
This struct is not for sharing with other functions.
This is not a general purpose "params" struct,
but a struct whose sole purpose is to plumb arguments to this function.

All arguments except context, that is.
That remains the first argument to your function.

You can add new *optional* fields to this struct.
That's completely backwards compatible.

As a general rule of thumb:
if your function takes more than three parameters,
it will inevitably need more.
Use a struct.
--

[.columns]
=== Result Objects

[.column]
--
[source,diff]
----
 type DeleteUserResponse struct {
   Deleted bool
+  UUID    uuid.UUID
 }
----

[source,go]
----
func DeleteUser(
  ...
) (DeleteUserResponse, error) {
  // ...
}
----
--

[.column.text-left]
--
`struct` *exclusively* for returns except error

[.medium]
New fields for new outputs

[%step.small]
Need more than 2 results? +
Use a `struct`.
--

[.notes]
--
Result objects are the analog of parameter objects
for returning values.
They're equally simple.
A struct that exists solely to hold values returned by a function.
All except the `error`, which should remain the last output of your function.

You can add new fields to this struct -- new things your function needs to
return,
and that's completely backwards compatible.

Similar rule of thumb applies here.
Need to produce more than two things?
Return a struct.
--

[.columns%auto-animate]
=== Functional Options

[.column]
[source%linenums,go,data-id=decls]
----
type Option /* ... */

func SkipAuthors(
  names ...string,
) Option { /* ... */ }

func ListPosts(
  ctx context.Context,
  opts ...Option,
) ([]*Post, error)
----

[.column]
[source%linenums,go,data-id=usage]
----
ListPosts(ctx)

ListPosts(ctx,
  SkipAuthors(...),
)
----

[.notes]
--
Lastly there are functional options.

With functional options, you define an opaque `Option` type.
Users cannot construct these except by using
functions that you provide.

The function accepts a variable number of these
and interprets them "internally".
Users can pass them or not.
--

[.columns%auto-animate]
=== Functional Options

[.column]
[source%linenums,go,data-id=decls]
----
type Option /* ... */

func SkipAuthors(
  names ...string,
) Option { /* ... */ }

func Archived(
  bool,
) Option { /* ... */ }

func ListPosts(
  ctx context.Context,
  opts ...Option,
) ([]*Post, error)
----

[.column]
[source%linenums,go,data-id=usage]
----
ListPosts(ctx)

ListPosts(ctx,
  Archived(true),
  SkipAuthors(...),
)

ListPosts(ctx,
  Archived(false),
)
----

[.notes]
--
You can add new options and again,
users can pass them or not.

You can go pretty wild with the number of options.
--

=== Functional Options

Good for,

* Default behavior
* Lots of customization

[.notes]
--
Functional options are good candidates for cases where
there's a good zero option default behavior
and you want freedom to add tonnes of options on top.
--

=== Implementing Functional Options

[.notes]
--
There are a couple ways to implement functional options.
I'll go over the one I recommend.
--

[.columns%auto-animate%conceal]
=== Implementing Functional Options

[.column]
[source%linenums,go,data-id=def]
----
type options struct {
}

type Option interface {
  apply(*options)
}
----

[.column]
{blank}

[.notes]
--
To implement functional options,
define an *unexported* options struct,
a public Option interface,
and add an *unexported* method on this interface
that accepts a pointer to that struct.

The unexported method on the interface "seals"
this interface.
Nobody outside this package can implement this interface.
--

[.columns%auto-animate%conceal]
=== Implementing Functional Options

[.column]
[source%linenums,go,data-id=def]
----
type options struct {
  skipAuthors []string
}

type Option interface {
  apply(*options)
}
----

[.column]
[source,go]
----
func SkipAuthors(
  xs ...string,
) Option {
  return skipAuthors(xs)
}

type skipAuthors []string

func (o skipAuthors) apply(...) {
  opts.skipAuthors = []string(o)
}
----

[.notes]
--
* Add a field to this struct for the option.
* Build an implementation of the interface,
  that sets this option on the struct.
* Return that implementation from the option constructor.
--

[.columns%auto-animate%conceal]
=== Implementing Functional Options

[.column]
[source%linenums,go,data-id=def]
----
type options struct {
  skipAuthors []string
  archived    bool
  postedAfter time.Time
}

type Option interface {
  apply(*options)
}
----

[.column]
[source,go]
----
func SkipAuthors(
  xs ...string,
) Option { /* ... */ }

func Archived(
  archived bool,
) Option { /* ... */ }

func PostedAfter(
  postedAfter date.Date,
) Option { /* ... */ }
----

[.notes]
--
Do this for every option.
--

[.columns%auto-animate%conceal]
=== Implementing Functional Options

[.column]
[source%linenums,go,data-id=def]
----
type options struct {
  skipAuthors []string
  archived    bool
  postedAfter time.Time
}

type Option interface {
  apply(*options)
}
----

[.column]
[source,go]
----
func ListPosts(
  ctx context.Context,
  os ...Option,
) (...) {
  var opts options
  for _, o := range os {
    o.apply(&opts)
  }
  // ...
  if opts.archived {
    where = append(where,
      "archived = TRUE")
  }
  // ...
----

[.notes]
--
Finally, in your function,
compile these options into the final options struct.
And consume the result.

Lastly, one more cool thing about functional options.
These are not just for accepting new optional parameters.
In a pinch, you can also use them to produce new optional results.
--

[.columns%auto-animate%conceal]
=== Not only for parameters

[.column]
[source%linenums,go,data-id=def]
----
type options struct {
  skipAuthors []string
  archived    bool
  postedAfter time.Time
  queryStats *Stats
}

type Stats struct {
  Elapsed time.Duration
  /* ... */
}

func QueryStats(*Stats) Option {
  /* ... */
}
----

[.column]
[source,go]
----
var stats Stats
posts, err := ListPosts(ctx,
  QueryStats(&stats),
)
if err != nil {
  // ...
}

log.Printf(
  "Query took %v", stats.Elapsed)
// Output:
// Query took 100ms
----

[.notes]
--
To do this, you add an option that accepts a pointer to the variable
that should be filled with the results.

In this example, I'm adding an option that calculates statistics
about the SQL query my system ran and posts them to the given struct.

This is especially useful if the optional result requires extra work
that you'd rather not do if the caller doesn't want it.
If the pointer is nil, don't calculate the statistics.
--

=== Functional Options

* Very flexible
* High boilerplate

[.notes]
--
*Whew*.
That was a lot.
Functional options let you do a lot.
They're very flexible.
But they're also heavy on the boilerplate.

Use them only when the boilerplate is worth it.

As an aside, I mentioned that there are other ways to implement functional
options.
For example, you can use function pointers and that's less boilerplate,
but still quite a bit.
But function pointers loses some nice properties of the interface based
approach when it comes to debugging and testing
that I don't have time to cover right now.

Just for now:
if you're gonna do functional options, prefer the interface based approach.
--

=== Plan for expansion

Parameter Objects +
Result Objects +
Functional Options +
[.step]#New Functions#

[.notes]
--
Okay, so to plan for function expansion,
you have parameter objects,
result objects,
and functional options.

Anything else?

Yes!
If all else fails,
you can always just write a new function.
... except if you're inside an interface.

Next, let's talk about interfaces.
--

== {rule-interfaces}

How to plan for expansion?

[.notes]
--
So as we discussed earlier,
interfaces are immutable.
You cannot make changes to them once published.

How do we plan for expansion here?
--

[.columns.wrap]
=== Keep interfaces small

[.column]
--
Bad

[source,go]
----
type Writer interface {
  WriteBytes([]byte) error
  WriteString(string) error
}

func (w *myWriter) WriteString(
  s string,
) error {
  return w.WriteBytes([]byte(s))
}
----
--

[.column,step=1]
--
Good

[source,go]
----
type Writer interface {
  WriteBytes([]byte) error
}

func WriteString(
  w Writer, s string,
) error {
  return w.WriteBytes([]byte(s))
}
----
--

[.column.is-full,step=1]
No helper methods -- use functions

[.notes]
--
Well, the first thing we do is we keep them small.

In this example,
nearly every implementation of WriteString will
have that exact same body.
Convert the string to bytes, and use WriteBytes.

This does not need to be a method on the interface.
Move it into a top level function.

Besides making your interface smaller,
this also avoids the need to copy paste
the same implementation of WriteString everywhere.

Okay that might have you wondering,
but what about the few cases where WriteString
is not implemented in terms of WriteBytes?
Don't I lose the ability to override that behavior.

Not quite. The next technique you can use here is upcasting.
--

[%auto-animate]
=== Upcast to upgrade

[source%linenums,go,data-id=writer]
----
type Writer interface{ WriteBytes([]byte) error }

func WriteString(w Writer, s string) error {
  return w.WriteBytes([]byte(s))
}
----

[.notes]
--
So I have my Writer interface that supports bytes,
and my WriteString function that lets me use
Writers to write strings.

How do I add the ability for *some* implementations of the interface
to provide an alternative WriteString implementation?
--

[%auto-animate]
=== Upcast to upgrade

[source%linenums,go,data-id=writer]
----
type Writer interface{ WriteBytes([]byte) error }

type StringWriter interface{ WriteString(string) error }

func WriteString(w Writer, s string) error {
  return w.WriteBytes([]byte(s))
}
----

Add a new interface

[.notes]
--
First, I add a *new* interface that matches the signature of the function.

This is the interface we want Writers to implement if they want to upgrade.
--

[%auto-animate]
=== Upcast to upgrade

[source%linenums,go,data-id=writer]
----
type Writer interface{ WriteBytes([]byte) error }

type StringWriter interface{ WriteString(string) error }

func WriteString(w Writer, s string) error {
  if sw, ok := w.(StringWriter); ok {
    return sw.WriteString(s)
  }
  return w.WriteBytes([]byte(s))
}
----

Upcast to optimized implementation

[.notes]
--
Next, the helper function upcasts to the new interface.
*If* the given writer implements StringWriter, use that implementation.
Otherwise, fall back to the WriteBytes-based implementation.

This is a pretty simple technique, and you can see it used in many places in
the standard library.
As an example, let's look at the io/fs package.
--

[%auto-animate]
=== io/fs

[source,go,data-id=fs]
----
type FS interface{
  Open(string) (File, error)
}
----

[%step]
[source,go]
----
type StatFS interface {
  FS

  Stat(string) (FileInfo, error)
}

func Stat(fs FS, name string) (FileInfo, error) {
  if sf, ok := fs.(StatFS); ok {
    return sf.Stat(name)
  }

  f, err := fs.Open(name)
  // ...
  return f.Stat()
}
----

[.notes]
--
io/fs defines a simple FS interface.
It can only open a file and nothing else.

However, given that ability, you can "stat" a file -- inspect it -- with an
optional upgrade where you don't have to open it to stat it.
--

[%auto-animate]
=== io/fs

[source,go,data-id=fs]
----
type FS interface{
  Open(string) (File, error)
}
----

[source,go]
----
type ReadFileFS interface {
  FS

  ReadFile(string) ([]byte, error)
}

func ReadFile(fs FS, name string) ([]byte, error) {
  if rf, ok := fs.(ReadFileFS); ok {
    return rf.ReadFile(name)
  }

  f, err := fs.Open(name)
  // ...
  return io.ReadAll(f)
}
----

[.notes]
--
You can read from the file,
again, with an optional upgrade path.

Note that this is not the actual implementation,
but you should get the idea.

And you can do other things -- I'm not gonna list all here.
--

=== Small Driver, Big Wrapper

Small driver with a rich API around it.

[source,go]
----
type Driver interface { ... }
----

== Practices

== Object Initialization

* Always fully hydrates
* Constructor
* sync.Once pattern?

[.notes]
--
--

== Goroutine management

* Always control the lifetime
* Don't fire and forget
* No unstoppable background worker

// TODO: worker pool, stop method, etc.

== Errors

* Producing
* Consuming

== Produce errors

* errors.New, fmt.Errorf
* Sentinel errors
* Structured errors

== Consume errors

* Handle the error
* Propagate the error

== Handle errors

* match the error with errors.Is
* extract information with errors.As
* log the error

== Propagate errors

* return as-is
* add context with fmt.Errorf, use %w
* add information with structured error

== Discussion
