[.columns]
= Variadic arguments

[.column]
--
[source,diff]
----
 func ListPosts(
   ctx context.Context,
+  skipAuthors ...string
 ) ([]*Post, error)
----

This is fine, right?

[source,go]
----
posts, err := ListPosts(ctx)
if err != nil {
  // ...
}
----

[step=1]
Nope!
--

[.column.is-three-fifths]
--
[source,go,step=2]
----
func Process(
  ctx context.Context,
  listPosts func(...) ([]*Post, error)
) {
  posts, err := listPosts(ctx)
  // ...
}
----

[step=4]
Breaks function references

[step=3]
[source,go]
----
Process(ctx, ListPosts)
// ERROR:
// want func(Context) (...)
//  got func(Context, ...string) (...)
----
--

[.notes]
--
Aha, some of you might be thinking.
What if I add variadic arguments to a function?
Surely, that's a backwards compatible change?
Surely, that won't break anyone.

Wrong.
Go supports function references.
When you pass a function reference,
the type is usually inferred.
Changing that type is a breaking change.
--
