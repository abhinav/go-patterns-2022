= Driver Interface

[.notes]
--
Okay, so I don't know if there's a real name for this pattern.
I'm just making the name up.

Let me first explain the pattern at a high level,
and then I'll demonstrate with code.
--

[%auto-animate]
== !

[mermaid,data-id=img]
....
flowchart LR
  subgraph Driver
    WriteBytes
  end
....

[.notes]
--
In this pattern, you start with a "Driver" interface
with the most minimal API.
--

[%auto-animate]
== !

[mermaid,data-id=img]
....
flowchart LR
  subgraph Writer
    WriteBytesOut[WriteBytes]
  end

  subgraph Driver
    WriteBytes
  end

  WriteBytesOut --> WriteBytes
....

[.notes]
--
You build a struct around it, say, Writer,
that provides roughly the same API.

But then on top of that, you can add other functionality
that depends on the small interface.
--

[%auto-animate]
== !

[mermaid,data-id=img]
....
flowchart LR
  subgraph Writer
    WriteBytesOut[WriteBytes]
    WriteString
  end

  subgraph Driver
    WriteBytes
  end

  WriteBytesOut & WriteString --> WriteBytes
....

[.notes]
--
This is similar to exporting a top-level function,
except it still provides all methods on the same object.

Let me demonstrate with code quickly.
--

[%auto-animate%auto-animate-restart]
== !

[source,go]
----
type Driver interface {
  WriteBytes([]byte) error
}
----

[source%linenums,go,data-id=writer]
----
type Writer struct{ drv Driver }

func (w *Writer) WriteBytes(bs []byte) error {
  return w.drv.WriteBytes(bs)
}
----

[.notes]
--
I start with a Writer struct that has the same interface
as the driver.
--

[%auto-animate]
== !

[source%linenums,go,data-id=writer]
----
type Writer struct{ drv Driver }

func (w *Writer) WriteBytes(bs []byte) error {
  return w.drv.WriteBytes(bs)
}

func (w *Writer) WriteString(bs []byte) error {
  return w.WriteBytes([]string(bs))
}
----

[.notes]
--
And then I do the same thing I did with the
top-level WriteString function earlier,
but as a method.

I can support upcasting on this interface too!
--

[%auto-animate]
== !

[source%linenums,go,data-id=writer]
----
type Writer struct{ drv Driver }

func (w *Writer) WriteBytes(bs []byte) error {
  return w.drv.WriteBytes(bs)
}

type StringWriter interface {
  WriteString(string) error
}

func (w *Writer) WriteString(bs []byte) error {
  if sw, ok := w.drv.(StringWriter); ok {
    return sw.WriteString(s)
  }
  return w.WriteBytes([]string(bs))
}
----

[.notes]
--
So I'm sort of able to give my users the best of both worlds.
--

== Benefits

* Implement a small interface
* Consume a large surface
* Store internal state

[.notes]
--
Users that want to implement the interface
only have to implement as little of it as they need.

Users that want to *consume* the functionality provided by it,
can consume the struct and get a much richer API.

And lastly, these method implementations can store information on the wrapper
object.
--

== Examples

* `zap.Logger` wraps `zapcore.Core`
* `http.Client` wraps `http.RoundTripper`
* `database/sql` wraps `database/sql/driver`

[.notes]
--
Some real world examples of this include,

* our very own Zap
* Go's standard HTTP client,
  and database/sql where most types in the SQL package
  wrap thinner interfaces inside driver.
--
